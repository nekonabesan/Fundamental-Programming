//============================================================================//
// 演習 1 2 番目の (getl を含む方の) 例題を打ち込んで動かしなさい。
// OK なら、次のものをやってみなさい。
// 関数を作ったら、その動作が確認できるように呼び出してみること。
//============================================================================//
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
//============================================================================//
// a. getl で入力した文字列は毎回長さが違っているので、その長さを調べたい。
// 文字列の長さを調べて返す関数 int mystrlen(char s[]) を作れ。
// (ヒント: printtriangle の中で [i] == ’\0’ が成立したときの i は文字列の長さの値になっている。)
//============================================================================//
int mystrlen(char s[]){
  int result = 0;
  while(1){
    if(s[result] == '\0'){
      break;
    }
    result++;
  }
  return result;
}

//============================================================================//
// b. printtriangleでは1行ごとに先頭の文字が削られて行が短くなっていたが、
// それと似ているが1行ごとに末尾の文字が削られて短くなっていく
// 関数void printtriangletail(chars[]) を作れ。
// (ヒント: 文字列のどの位置でも、ナル文字を代入したらそこが文字列の終わりになる。)
//============================================================================//
void prchartriangletail(char s[]){
  int l = mystrlen(s);
  s[l - 1] = '\0';
}

//============================================================================//
// c. 文字列の中に現れる文字 c1 を文字 c2 に置き換える
// (たとえば空白を*に置き換えたりできる) 関数 void mapchar(char s[], char c1, char c2) を作れ。
//============================================================================//
void mapchar(char s[], char c1, char c2){
  for(int i = 0; i < mystrlen(s); i++){
    if(s[i] == c1){
      s[i] = c2;
    }
    if(s[i] == '\0'){
      break;
    }
  }
}

//============================================================================//
// d. 文字列中の指定した文字 c1 をすべて削除して詰める
// 関数 void deletechar(char s[],char c1) を作れ。
//============================================================================//
void deletechar(char s[],char c1){
  int l = mystrlen(s);
  int cnt = 0;
  char *s2 = (char *)malloc((l + 1) * sizeof(char));
  for(int i = 0; i <= l; i++){
    if(s[i] != c1){
      s2[cnt] = s[i];
      cnt++;
    }
  }
  l = mystrlen(s2) + 1;
  for(int j = 0; j < l; j++){
    s[j] = s2[j];
  }
  free(s2);
}

//============================================================================//
// e. 文字列を左右ひっくり返す関数 void reverse(char s[]) を作れ。
//============================================================================//
void reverse(char s[]){
  int l = mystrlen(s);
  int j = l;
  char *s2 = (char *)malloc(l * sizeof(char));
  for(int i = 0; i < l; i++){
    j--;
    s2[i] = s[j];
    s2[i + 1] = '\0';
  }
  for(int i = 0; i < l; i++){
    s[i] = s2[i];
    s[i + 1] = '\0';
  }
  free(s2);
}


//============================================================================//
// f. 文字列 s2 の内容を別の文字配列 s1 にコピーする関数
// void mystrcpy(char s1[], chars2[]) を作れ。
//============================================================================//
void mystrcpy(char s1[], char s2[]){
  for (size_t i = 0; i < mystrlen(s1); i++) {
    s2[i] = s1[i];
    s2[i + 1] = '\0';
  }
}

//============================================================================//
// g. 文字列s2の内容を別の文字列s1の末尾に追加する(くっつける) 関数
// void mystrcat(chars1[], char s2[]) を作れ。
//============================================================================//
void mystrcat(char s1[], char s2[]){
  int l = mystrlen(s1);
  s1 = (char *)realloc(s1 ,sizeof(char) * l);
  for(int i = 0; i < mystrlen(s2); i++){
    s1[l + i] = s2[i];
    s1[l + i + 1] = '\0';
  }
}

//============================================================================//
// h. 文字列 s1 と s2 を比較して等しければ 0、1 番目のものがコード順で
// 後なら 1、前なら-1 を返す関数 int mystrcmp(char s1[], char s2[]) を作れ。
// たとえば mystrcmp("abcd","abcd") → 0、mystrcmp("abcd", "abaa") → 1、
// mystrcmp("abcd", "abcz") → -1となる。
// (ヒント: 先頭から両方の文字列を比べていき、最後まで (ナル文字まで) 同じなら等しい。
// そうでなければ、違いがあったところの対応する文字の大小関係で 1 か-1 を返せばよい。)
//============================================================================//
int mystrcmp(char s1[], char s2[]){}
