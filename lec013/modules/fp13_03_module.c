#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
//============================================================================//
// 演習 3 このプログラムをそのまま動かしなさい。
// OK なら、目印を先頭位置に 1 文字表示するのでなく、
// pat のあてはまる範囲に連続して表示するように直してみなさい。
//============================================================================//
//============================================================================//
// 演習 4 上のコードを打ち込み、パターンが正しく処理されていることを確認しなさい。
// OK なら、次のことをやってみなさい。
//============================================================================//
void concat_prefix(char c2[], int start, int len){
  int l = strlen(c2);
  char *buf = (char *)malloc(l * sizeof(char));
  int pos = 0;
  int j = 0;
  int end = start + len;
  for(int i = 0; i < l; i++){
    if(c2[pos] == '\0'){
      break;
    } else if(start <= i  && i < end){
      pos++;
    } else {
      buf[j] = c2[pos];
      buf[i + 1] = '\0';
      j++;
      pos++;
    }
  }
  c2 = (char *)realloc(c2 ,sizeof(char) * (l - len));
  for(int i = 0; i < strlen(c2); i++){
    c2[i] = buf[i];
  }
  c2[l - 1] = '\0';
  free(buf);
}
//============================================================================//
// c. ^(先頭に固定) を実現してみなさい。
//============================================================================//
bool chk_prefix(char c2[]){
  int l = strlen(c2);
  if(c2[0] == 0x5e){
    concat_prefix(c2, 0, 1);
    return true;
  } else if(c2[0] == 0x5c) {
    //========================================================================//
    // e. ここまでに出て来た特殊文字の機能をなくすエスケープ記号「\」を実現しなさい
    // (この文字に続いて特殊文字があった場合通常の文字として扱う)。
    //========================================================================//
    concat_prefix(c2, 0, 1);
    return false;
  }
  return false;
}
//============================================================================//
// c. $(末尾に固定) を実現してみなさい。
//============================================================================//
bool chk_suffix(char c2[]){
  int l = strlen(c2);
  if(c2[l - 2] == 0x5c){
    //========================================================================//
    // e. ここまでに出て来た特殊文字の機能をなくすエスケープ記号「\」を実現しなさい
    // (この文字に続いて特殊文字があった場合通常の文字として扱う)。
    //========================================================================//
    concat_prefix(c2, l - 2, 1);
    return false;
  } else if(c2[l - 1] == 0x24){
    concat_prefix(c2, (l - 1), 1);
    return true;
  }
  return false;
}

//====================================================//
// param  chr *match
// param  chr *pattern
// return int result
//====================================================//
int mach(char c1[], char c2[]) {
  if(c1 == "" || c2 == "" || c1 == NULL || c2 == NULL){
    return -1;
  }
  // 接頭語チェック
  bool prefix = chk_prefix(c2);
  // 接尾語チェック
  bool suffix = chk_suffix(c2);

  //
  char *match = c1;
  char *pattern = c2;
  int l1 = strlen(c1);
  int l2 = strlen(c2);
  bool flg = false;
  //
  for(int i = 0; i < l1; i++){
    for(int j = 0; j < l2; j++){
      if(match[i] != pattern[j]){
        flg = false;
        break;
      }else{
        flg = true;
      }
    }
    if(flg == true){
      return i;
    }
  }
  return -1;
}
