require __dir__ + "/spec_helper"
require __dir__ + '/../fp01_04.rb'

describe " 演習4" do
  #/----------------------------------------------------------------/
  #a. 係数 a, b, c の値を引数として渡すと、2 つの解を打ち出す (または「[値, 値]」の形で返す)
  #メソッドを作成しなさい。いくつかの値で実行例を示すこと。
  #/----------------------------------------------------------------/
  describe "a" do
    it "calc_a(1,2,1)" do
      results = calc_a(1,2,1)
      expect(results[0]).to eq -1.0
      expect(results[1]).to eq -1.0
    end
    it "calc_a(1,-2,1)" do
      results = calc_a(1,-2,1)
      expect(results[0]).to eq 1.0
      expect(results[1]).to eq 1.0
    end
    it "calc_a(0.01,0.02,0.01)" do
      results = calc_a(0.01,0.02,0.01)
      expect(results[0]).to eq -1.0
      expect(results[1]).to eq -1.0
    end
    it "calc_a(0.001,0.002,0.001)" do
      results = calc_a(0.001,0.002,0.001)
      expect(results[0]).to eq -1.0
      expect(results[1]).to eq -1.0
    end
    it "calc_a(1,nil,1)" do
      results = calc_a(1,nil,1)
      expect(results).to be_a(RuntimeError)
    end
  end
  #/----------------------------------------------------------------/
  #b. 上記に加えて、|b| と |√b
  #2 − 4ac| が非常に近い場合を解かせてみて、桁落ちによる誤差が
  #現れることを観察しなさい。いくつかの実行例を示すこと。
  #ヒント: (x + d)(x + 1) で d が非常に 0 に近い値 (たとえば 0.000000000012345 とか) はそ
  #うなるでしょう。この式を展開して a, b, c を決めればいいいわけです。
  #/----------------------------------------------------------------/
  # irb(main):026:0> calc_a(1,1.00000000012345,0.00000000012345)
  # => [-0.9999999999999999, -1.234500279778672e-10]
  describe "b" do
    it "calc_a(1,1.00000000012345,0.00000000012345)" do
      results = calc_a(1,1.00000000012345,0.00000000012345)
      expect(results[0].to_s).to match(/^[-]*?[0-9]{1}\.[0-9]+[e]*?[+-]*?[0-9]+$/)
      expect(results[1].to_s).to match(/^[-]*?[0-9]{1}\.[0-9]+[e]*?[+-]*?[0-9]+$/)
    end
  end
  #/----------------------------------------------------------------/
  #c. 仮に b ≥ 0 とする (負なら a, b, c すべてに −1 を掛ければ解は同じで b ≥ 0 とできる)。す
  #ると、± のうち − については両方の符号が同じなので桁落ちなしに解が求まる。これを α
  #とおき、解と係数の関係 αβ =ca を利用して他方の解 β を求めることができる。この方法
  #で 2 つの解を求めて打ち出す (または「[値, 値]」の形で返す) メソッドを作成しなさい。
  #いくつかの値で実行例を示すこと。
  #/----------------------------------------------------------------/
  describe "c" do
    # irb(main):004:0> calc_c(1,1.00000000123,0.00000000123)
    # => [-1.0, -1.23e-09]
    it "calc_c(1,1.00000000123,0.00000000123)" do
      results = calc_c(1,1.00000000123,0.00000000123)
      expect(results[0]).to eq -1.0
      expect(results[1].to_s).to match(/^[-]*?[0-9]{1}\.[0-9]+[e]*?[+-]*?[0-9]+$/)
    end
    # irb(main):008:0> calc_c(1,-1.0000000012345,0.0000000012345)
    # => [1.0, 1.2345e-09]
    it "calc_c(1,-1.0000000012345,0.0000000012345)" do
      results = calc_c(1,-1.0000000012345,0.0000000012345)
      expect(results[0]).to eq 1.0
      expect(results[1].to_s).to match(/^[-]*?[0-9]{1}\.[0-9]+[e]*?[+-]*?[0-9]+$/)
    end
    # irb(main):010:0> calc_c(1,1.000000000012345,0.000000000012345)
    # => [-1.0, -1.2345e-11]
    it "irb(main):006:0> calc_c(1,1.000000000012345,0.000000000012345)" do
      results = calc_c(1,1.000000000012345,0.000000000012345)
      expect(results[0]).to eq -1.0
      expect(results[1].to_s).to match(/^[-]*?[0-9]{1}\.[0-9]+[e]*?[+-]*?[0-9]+$/)
    end
  end
  #/----------------------------------------------------------------/
  #d. 上記の設問 b で桁落ち誤差のあった実行例が c のプログラムでは問題なく計算できること
  #を観察しなさい。いくつかの実行例を示すこと。
  #/----------------------------------------------------------------/
  describe "d" do
    it "" do

    end
  end

end
