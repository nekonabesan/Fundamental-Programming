活動内容報告 ＃12
学籍番号:1820004
氏名:大竹春生
ペア学籍番号・氏名(または「個人作業」):個人作業
提出日付:


「演習 1」または「演習 2」で動かしたプログラム (どれか 1 つでよい) を含むレポートを提出しなさい。
プログラムと、簡単な説明が含まれること。アンケートの回答もおこなうこと。

演習 1 上の例題を打ち込んで実行せよ ( 一部を出力するところも追加して動かしてみること ) 。
うまく動いたら、次のような関数を追加してみよ。
a. 整数配列を「後ろから順に」打ち出す関数 void piarrayrev(int n, int a[]) 。
b. 整数配列と整数値を渡し、指定した整数値が配列の何番に入っているかを返す ( 入ってい
なければ -1 を返す ) 関数 int iindex(int n, int a[], int x) 。
c. 整数配列の最大値を返す関数 int maxiarray(int n, int a[]) 。
d. 整数配列の最小値を返す関数 int miniarray(int n, int a[]) 。
e. 整数配列の合計値を返す関数 int sumiarray(int n, int a[]) 。
f. 整数配列の平均値を返す関数 double avgiarray(int n, int a[]) 。
g. 実数配列の打ち出し / 後ろから順に打ち出し / 最大値 / 最小値 / 合計値 / 平均値を返す関数。
h. 好きな方法で整数配列を整列する関数。テスト用に乱数が必要なら付録を参照のこと。
i. その他配列を受け取り好きな処理をする関数。

[作成したプログラム]
/=======================lec012/modules/fp12_01_module.c========================/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

const int TRUE = 1;
const int FALSE = 0;

//============================================================================//
// 演習 1 上の例題を打ち込んで実行せよ ( 一部を出力するところも追加して動かしてみること ) 。
// うまく動いたら、次のような関数を追加してみよ。
//============================================================================//
void sort2(double a, double b, double *p, double *q){
   if(a < b){
     *p = a;
     *q = b;
   }else{
     *p = b;
     *q = a;
   }
}

void piarray(int n, int a[]){
  for(int i = 0; i < n; i++){
    printf(" %2d", a[i]);
    if(i % 10 == 9 || i == n - 1){
      printf("\n");
    }
  }
}



//============================================================================//
// a. 整数配列を「後ろから順に」打ち出す関数 void piarrayrev(int n, int a[])。
//============================================================================//
void piarrayrev(int n, int a[]){
  for(int i = n; n > 0; i--){
    printf("%d", a[i]);
  }
}

//============================================================================//
// b. 整数配列と整数値を渡し、指定した整数値が配列の何番に入っているかを返す (入ってい
// なければ-1 を返す) 関数 int iindex(int n, int a[], int x)。
//============================================================================//
int iindex(int n, int a[], int x){
  int result = -1;
  for(int i = 0; n > i; i++){
    if(a[i] == x){
      result = i;
    }
  }
  return result;
}
//============================================================================//
// c. 整数配列の最大値を返す関数 int maxiarray(int n, int a[])。
//============================================================================//
int maxiarray(int n, int a[]){
  int max = a[0];
  for(int i = 0; n > i; i++){
    if(a[i] > max){
      max = a[i];
    }
  }
  return max;
}

//============================================================================//
// d. 整数配列の最小値を返す関数 int miniarray(int n, int a[])。
//============================================================================//
int miniarray(int n, int a[]){
  int min = a[0];
  for(int i = 0; n > i; i++){
    if(min > a[i]){
      min = a[i];
    }
  }
  return min;
}

//============================================================================//
// e. 整数配列の合計値を返す関数 int sumiarray(int n, int a[])。
//============================================================================//
int sumiarray(int n, int a[]){
  int result = 0;
  for(int i = 0; n > i; i++){
    result += a[i];
  }
  return result;
}

//============================================================================//
// f. 整数配列の平均値を返す関数 double avgiarray(int n, int a[])。
//============================================================================//
double avgiarray(int n, int a[]){
  double result = 0;
  for(int i = 0; n > i; i++){
    result += a[i];
  }
  return result / n;
}

//============================================================================//
// g. 実数配列の打ち出し/後ろから順に打ち出し/最大値/最小値/ 合計値/平均値を返す関数。
//============================================================================//
void g01(int n, double a[]){
  for(int i = 0; n > i; i++){
    printf("%f ", a[i]);
  }
}

void g02(int n, double a[]){
  for(int i = n; i > n; i--){
    printf("%f ", a[i]);
  }
}

double g03(int n, double a[]){
  double max = a[0];
  for(int i = 0; n > i; i++){
    if(a[i] > max){
      max = a[i];
    }
  }
  return max;
}

double g04(int n, double a[]){
  double min = a[0];
  for(int i = 0; n > i; i++){
    if(min > a[i]){
      min = a[i];
    }
  }
  return min;
}

double g05(int n, double a[]){
  double result = 0.0;
  for(int i = 0; i < n; i++){
    result += a[i];
  }
  return result;
}


double g06(int n, double a[]){
  double result = 0;
  for(int i = 0; n > i; i++){
    result += a[i];
  }
  return result / n;
}

//============================================================================//
// h. 好きな方法で整数配列を整列する関数。テスト用に乱数が必要なら付録を参照のこと。
//============================================================================//
int* h(int n, int a[]){
  int index = 0;
  int tmp = 0;
  for(int i = 0; n > i; i ++){
    for(int j = n - 1; j > i; j--){
        tmp = 0;
        if(a[j - 1] > a[j]){
          tmp = a[j];
          a[j] = a[j - 1];
          a[j - 1] = tmp;
        }
    }
  }
  return a;
}
/=======================fp18/lec012/test/fp12_01/Makefile======================/
# Makefile
# all:より下の3行のインデント、
# gtest-gen:より下の1行のインデント
# は半角空白になっていますがタブ1個にしてください
# target.cはCなのでgccで、それ以外はC++なのでg++でビルドします
# gtest_main.ccはGoogleTestが用意してくれているmain関数、
# gtest-all.ccがGoogleTest全部入りファイルです
# -lpthreadをつけることにも注意。
# makeかmake allしたらビルドして実行まで行います。
all:
			gcc -c ../../modules/fp12_01_module.c
			g++ fp12_01_test.cpp googletest-release-1.8.1/googletest/src/gtest_main.cc gtest/gtest-all.cc -I. -lpthread fp12_01_module.o
			./a.out
gtest-gen:
			python googletest-release-1.8.1/googletest/scripts/fuse_gtest_files.py ./
clean:
			rm -f ./a.out
			rm -f ./fp12_01_module.o
/==============================================================================/
/===================fp18/lec012/test/fp12_01/fp12_01_terget.h==================/
// テスト対象関数のプロトタイプ宣言
#ifndef _TARGET_H_
#define _TARGET_H_

void sort2(double a, double b, double *p, double *q);
void piarrayrev(int n, int a[]);
int iindex(int n, int a[], int x);
int maxiarray(int n, int a[]);
int miniarray(int n, int a[]);
int sumiarray(int n, int a[]);
double avgiarray(int n, int a[]);
void g01(int n, double a[]);
void g02(int n, double a[]);
double g03(int n, double a[]);
double g04(int n, double a[]);
double g05(int n, double a[]);
double g06(int n, double a[]);
int* h(int n, int a[]);


#endif /* _TARGET_H_ */
/==============================================================================/
/===================fp18/lec012/test/fp12_01/fp12_01_test.c====================/
#define RMAX 1000
#define TRUE 1
#define FALSE 0

// テストケース記述ファイル
#include "gtest/gtest.h" // googleTestを使用するおまじないはこれだけでOK
// テスト対象関数を呼び出せるようにするのだが
// extern "C"がないとCと解釈されない、意外とハマりがち。
extern "C" {
  #include "fp12_01_target.h"
}

// fixtureNameはテストケース群をまとめるグループ名と考えればよい、任意の文字列
// それ以外のclass～testing::Testまではおまじないと考える
class fixtureName : public ::testing::Test {
protected:
    // fixtureNameでグループ化されたテストケースはそれぞれのテストケース実行前に
    // この関数を呼ぶ。共通の初期化処理を入れておくとテストコードがすっきりする
    virtual void SetUp(){
    }
    // SetUpと同様にテストケース実行後に呼ばれる関数。共通後始末を記述する。
    virtual void TearDown(){
    }
};

// 成功するテストケース。細かい説明はGoogleTestのマニュアルを見てね。
TEST_F(fixtureName, initialize)
{
  //initialize では先のアルゴリズムによって roomprice を順に初期化しています
  //int *roomprice = (int *)malloc(rmax * sizeof(int));
  //int *roomsel = (int *)malloc(rmax * sizeof(int));
}

//============================================================================//
// a. 整数配列を「後ろから順に」打ち出す関数 void piarrayrev(int n, int a[])。
//============================================================================//
TEST_F(fixtureName, sort2)
{
  // 値を読み出す時には room1 という下請け関数を呼びます。
  // この関数は、人数 i が負のときは 0 を返し、それ以外はroomprice[i] を返します。
}

//============================================================================//
// b. 整数配列と整数値を渡し、指定した整数値が配列の何番に入っているかを返す (入ってい
// なければ-1 を返す) 関数 int iindex(int n, int a[], int x)。
//============================================================================//
TEST_F(fixtureName, iindex)
{
  int a[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a) / sizeof(int);
  ASSERT_EQ(iindex(n,a,0),0);
  ASSERT_EQ(iindex(n,a,1),1);
  ASSERT_EQ(iindex(n,a,2),2);
  ASSERT_EQ(iindex(n,a,3),3);
  ASSERT_EQ(iindex(n,a,9),9);
  ASSERT_EQ(iindex(n,a,10),-1);
}

//============================================================================//
// c. 整数配列の最大値を返す関数 int maxiarray(int n, int a[])。
//============================================================================//
TEST_F(fixtureName, maxiarray)
{
  //test01
  int a1[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a1) / sizeof(int);
  ASSERT_EQ(maxiarray(n,a1),9);
  // test02
  int a2[] = {9,8,7,6,5,4,3,2,1,0};
  n = sizeof(a2) / sizeof(int);
  ASSERT_EQ(maxiarray(n,a2),9);
  // test02
  int a3[] = {-99,-1,0,5,100,999,-10,1};
  n = sizeof(a3) / sizeof(int);
  ASSERT_EQ(maxiarray(n,a3),999);
}

//============================================================================//
// d. 整数配列の最小値を返す関数 int miniarray(int n, int a[])。
//============================================================================//
TEST_F(fixtureName, miniarray)
{
  //test01
  int a1[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a1) / sizeof(int);
  ASSERT_EQ(miniarray(n,a1),0);
  // test02
  int a2[] = {9,8,7,6,5,4,3,2,1,0};
  n = sizeof(a2) / sizeof(int);
  ASSERT_EQ(miniarray(n,a2),0);
  // test02
  int a3[] = {-99,-1,0,5,100,999,-10,1};
  n = sizeof(a3) / sizeof(int);
  ASSERT_EQ(miniarray(n,a3),-99);
}

//============================================================================//
// e. 整数配列の合計値を返す関数 int sumiarray(int n, int a[])。
//============================================================================//
TEST_F(fixtureName, sumiarray)
{
  //test01
  int a1[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a1) / sizeof(int);
  ASSERT_EQ(sumiarray(n,a1),45);
  // test02
  int a2[] = {9,8,7,6,5,4,3,2,1,0};
  n = sizeof(a2) / sizeof(int);
  ASSERT_EQ(sumiarray(n,a2),45);
  // test02
  int a3[] = {-100,-10,-1,0,1,10,200};
  n = sizeof(a3) / sizeof(int);
  ASSERT_EQ(sumiarray(n,a3),100);
}

//============================================================================//
// f. 整数配列の平均値を返す関数 double avgiarray(int n, int a[])。
//============================================================================//
TEST_F(fixtureName, avgiarray)
{
  //test01
  int a1[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a1) / sizeof(int);
  ASSERT_EQ(avgiarray(n,a1),4.5);
  // test02
  int a2[] = {9,8,7,6,5,4,3,2,1,0};
  n = sizeof(a2) / sizeof(int);
  ASSERT_EQ(avgiarray(n,a2),4.5);
  // test02
  int a3[] = {-100,-10,-1,0,1,10,200};
  n = sizeof(a3) / sizeof(int);
  EXPECT_NEAR(avgiarray(n,a3),14.3,0.1);
}

//============================================================================//
// g. 実数配列の打ち出し/後ろから順に打ち出し/最大値/最小値/ 合計値/平均値を返す関数。
//============================================================================//
TEST_F(fixtureName, g01)
{
}

TEST_F(fixtureName, g02)
{
}

TEST_F(fixtureName, g03)
{
  // test01
  double a1[] = {0.0,1.0,2.0,3.0,4.0,5.0};
  double n = sizeof(a1)/sizeof(double);
  EXPECT_EQ(g03(n,a1),5.0);
  // test01
  double a2[] = {5.0,4.0,2.0,1,0,0.0};
  n = sizeof(a2)/sizeof(double);
  EXPECT_EQ(g03(n,a2),5.0);
  // test01
  double a3[] = {10000.1,0.0,1.0,-200.0,5.0,1.0};
  n = sizeof(a3)/sizeof(double);
  EXPECT_EQ(g03(n,a3),10000.1);
}

TEST_F(fixtureName, g04)
{
  // test01
  double a1[] = {0.0,1.0,2.0,3.0,4.0,5.0};
  double n = sizeof(a1)/sizeof(double);
  EXPECT_EQ(g04(n,a1),0.0);
  // test01
  double a2[] = {5.0,4.0,2.0,1,0,0.0};
  n = sizeof(a2)/sizeof(double);
  EXPECT_EQ(g04(n,a2),0.0);
  // test01
  double a3[] = {10000.1,0.0,1.0,-200.0,5.0,1.0};
  n = sizeof(a3)/sizeof(double);
  EXPECT_EQ(g04(n,a3),-200.0);
}

TEST_F(fixtureName, g05)
{
  // test01
  double a1[] = {0.0,1.0,2.0,3.0,4.0,5.0};
  double n = sizeof(a1)/sizeof(double);
  EXPECT_EQ(g05(n,a1),15.0);
  // test01
  double a2[] = {5.0,4.0,3.0,2.0,1,0,0.0};
  n = sizeof(a2)/sizeof(double);
  EXPECT_EQ(g05(n,a2),15.0);
  // test01
  double a3[] = {-5.5, -4.0, -3.3, -2.2, -1.1, 0.0, 1.1, 2.2, 3.3, 4.0, 5.5};
  n = sizeof(a3)/sizeof(double);
  EXPECT_EQ(g05(n,a3),0.0);
}

TEST_F(fixtureName, g06)
{
  //test01
  double a1[] = {0,1,2,3,4,5,6,7,8,9};
  int n = sizeof(a1) / sizeof(double);
  ASSERT_EQ(g06(n,a1),4.5);
  // test02
  double a2[] = {9,8,7,6,5,4,3,2,1,0};
  n = sizeof(a2) / sizeof(double);
  ASSERT_EQ(g06(n,a2),4.5);
  // test02
  double a3[] = {-100,-10,-1,0,1,10,200};
  n = sizeof(a3) / sizeof(double);
  EXPECT_NEAR(g06(n,a3),14.3,0.1);
}
// あえて失敗するテストケースも書いておく。
/*TEST_F(fixtureName, sqrt03)
{

}*/
/==============================================================================/

[簡単な説明]
プログラム自体は特筆すべき点はなし。
以下を参考にGoogleTestを試験的に導入。
https://qiita.com/igayu/items/9ff003309b237e9ae116
http://opencv.jp/googletestdocs/primer.html#primer-assertions

[アンケート]
Q1. C 言語のアドレスとポインタについてどう思いましたか。
資源管理の観点が不十分な実装を行った場合は危険と思われる。
Q2. C 言語の配列機能についてどう思いましたか。
終端の判定が曖昧な場合オーバーフローが生じる為、
参照対象の領域に関する考慮を欠いた実装を行うと危険と思われる。
Q3. 本日の全体的な感想と今後の要望をお書きください。
特になし。
