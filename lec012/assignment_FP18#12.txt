基礎プログラミングおよび演習レポート ＃12
学籍番号:1820004
氏名:大竹春生
ペア学籍番号・氏名(または「個人作業」):個人作業
提出日付:

[課題の再掲]
「演習 1」～「演習 7」の (小) 課題から 1 つ以上を選択してプログラムを作り、レポートを提出しなさい。
プログラムと、課題に対する報告・考察 (やってみた結果・そこから分かったことの記述) が含まれること。
アンケートの回答もおこなうこと。

[実施したこととその結果]
◆課題コード(演習4)
/========================lec012/modiles/fp12_04_module.c=======================/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define RMAX 1000
#define TRUE 1
#define FALSE 0

//============================================================================//
// 演習 4 上の例題を打ち込んでそのまま動かしなさい
// (最初はトレースバック無しの簡単な方を動かし、
// 動いてからトレースバックを追加した方が楽だと思います)。
// 動いたら、「13 人部屋 3 万円」「17 人部屋 4 万円」の選択肢を追加して動かしてみなさい。
//============================================================================//
int room1(int i, int *roomprice) {
  return (i < 0) ? 0 : roomprice[i];
}

// 1 人部屋:5,000 円、3 人部屋:12,000 円、7 人部屋:20,000 円
// 動いたら、「13 人部屋 3 万円」
//「17 人部屋 4 万円」の選択肢を追加して動かしてみなさい。
int initialize(int *roomprice, int *roomsel, int rmax) {
    if(roomprice == NULL || roomsel == NULL || rmax == 0){
        return FALSE;
    }

    roomprice[0] = 0;
    for (int i = 1; i < rmax; i++) {
      int min = room1(i - 1, roomprice) + 5000, sel = 1;
      if(min > room1(i - 3, roomprice) + 12000) {
        min = room1(i - 3, roomprice) + 12000; sel = 3;
      }
      if(min > room1(i - 7, roomprice) + 20000) {
        min = room1(i - 7, roomprice) + 20000; sel = 7;
      }
      if(min > room1(i - 13, roomprice) + 30000) {
        min = room1(i - 13, roomprice) + 30000; sel = 13;
      }
      if(min > room1(i - 17, roomprice) + 40000) {
        min = room1(i - 17, roomprice) + 40000; sel = 17;
      }
      roomprice[i] = min;
      roomsel[i] = sel;
    }

    return TRUE;
}
/==============================================================================/
/===============================lec012/fp12_04.c===============================/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "modules/fp12_04_module.c"

#define RMAX 1000
#define TRUE 1
#define FALSE 0
//============================================================================//
// 演習 4 上の例題を打ち込んでそのまま動かしなさい
// (最初はトレースバック無しの簡単な方を動かし、
// 動いてからトレースバックを追加した方が楽だと思います)。
// 動いたら、「13 人部屋 3 万円」「17 人部屋 4 万円」の選択肢を追加して動かしてみなさい。
//============================================================================//
int main(void){
  int n;
  int *roomprice = (int *)malloc(RMAX * sizeof(int));
  int *roomsel = (int *)malloc(RMAX * sizeof(int));

  initialize(roomprice, roomsel, RMAX);
  while(TRUE) {
    printf("input number (0 for end)> ");
    scanf("%d", &n);
    if(n == 0) {
      return 0;
    }
    if(n<0 || n >= RMAX-1) {
      printf("%d: invalid\\", n);
      continue;
    }
    printf("room price for %d => %d;", n, roomprice[n]);
    while(n > 0) {
      printf(" %d", roomsel[n]); n -= roomsel[n];
    }
    printf("\n");
  }

  free(roomprice);
  free(roomsel);
  return 1;
}
/==============================================================================/

◆テストコード(演習4)
/=========================lec012/test/fp12_04/Makefile=========================/
# Makefile
# all:より下の3行のインデント、
# gtest-gen:より下の1行のインデント
# は半角空白になっていますがタブ1個にしてください
# target.cはCなのでgccで、それ以外はC++なのでg++でビルドします
# gtest_main.ccはGoogleTestが用意してくれているmain関数、
# gtest-all.ccがGoogleTest全部入りファイルです
# -lpthreadをつけることにも注意。
# makeかmake allしたらビルドして実行まで行います。
all:
			gcc -c ../../modules/fp12_04_module.c
			g++ fp12_04_test.cpp googletest-release-1.8.1/googletest/src/gtest_main.cc gtest/gtest-all.cc -I. -lpthread fp12_04_module.o
			./a.out
gtest-gen:
			python googletest-release-1.8.1/googletest/scripts/fuse_gtest_files.py ./
clean:

			rm -f ./a.out
			rm -f ./fp12_04_module.o
/==============================================================================/
/====================lec012/test/fp12_04/fp12_04_targrt.h======================/
// テスト対象関数のプロトタイプ宣言
#ifndef _TARGET_H_
#define _TARGET_H_

int room1(int i, int *roomprice);
int initialize(int *roomprice, int *roomsel, int rmax);

#endif /* _TARGET_H_ */
/==============================================================================/
/====================lec012/test/fp12_04/fp12_04_test.cpp======================/
#define RMAX 1000
#define TRUE 1
#define FALSE 0

// テストケース記述ファイル
#include "gtest/gtest.h" // googleTestを使用するおまじないはこれだけでOK
// テスト対象関数を呼び出せるようにするのだが
// extern "C"がないとCと解釈されない、意外とハマりがち。
extern "C" {
  #include "fp12_04_target.h"
}

// fixtureNameはテストケース群をまとめるグループ名と考えればよい、任意の文字列
// それ以外のclass～testing::Testまではおまじないと考える
class fixtureName : public ::testing::Test {
protected:
    // fixtureNameでグループ化されたテストケースはそれぞれのテストケース実行前に
    // この関数を呼ぶ。共通の初期化処理を入れておくとテストコードがすっきりする
    virtual void SetUp(){
    }
    // SetUpと同様にテストケース実行後に呼ばれる関数。共通後始末を記述する。
    virtual void TearDown(){
    }
};

// 成功するテストケース。細かい説明はGoogleTestのマニュアルを見てね。
TEST_F(fixtureName, initialize)
{
  //initialize では先のアルゴリズムによって roomprice を順に初期化しています
  int rmax = 11;
  int *roomprice = (int *)malloc(rmax * sizeof(int));
  int *roomsel = (int *)malloc(rmax * sizeof(int));
  int *null_num = NULL;
  EXPECT_TRUE(initialize(roomprice, roomsel, rmax));
  EXPECT_FALSE(initialize(null_num, roomsel, rmax));
  EXPECT_FALSE(initialize(roomprice, null_num, rmax));
  EXPECT_FALSE(initialize(roomprice, roomsel, 0));
  free(roomprice);
  free(roomsel);
}
TEST_F(fixtureName, room1)
{
  // 値を読み出す時には room1 という下請け関数を呼びます。
  // この関数は、人数 i が負のときは 0 を返し、それ以外はroomprice[i] を返します。
  int rmax = 11;
  int *roomprice = (int *)malloc(rmax * sizeof(int));
  int *roomsel = (int *)malloc(rmax * sizeof(int));
  EXPECT_TRUE(initialize(roomprice, roomsel, rmax));
  ASSERT_EQ(room1(-2, roomprice), 0);
  ASSERT_EQ(room1(-1, roomprice), 0);
  ASSERT_EQ(room1(0, roomprice), 0);
  ASSERT_EQ(room1(1, roomprice), 5000);
  ASSERT_EQ(room1(2, roomprice), 10000);
  ASSERT_EQ(room1(3, roomprice), 12000);
  ASSERT_EQ(room1(4, roomprice), 17000);
  ASSERT_EQ(room1(5, roomprice), 20000);
  ASSERT_EQ(room1(6, roomprice), 20000);
  ASSERT_EQ(room1(7, roomprice), 20000);
  ASSERT_EQ(room1(8, roomprice), 25000);
  ASSERT_EQ(room1(9, roomprice), 30000);
  ASSERT_EQ(room1(10, roomprice), 30000);
  free(roomprice);
  free(roomsel);
}

TEST_F(fixtureName, room2)
{
  int rmax = 21;
  int *roomprice = (int *)malloc(rmax * sizeof(int));
  int *roomsel = (int *)malloc(rmax * sizeof(int));
  EXPECT_TRUE(initialize(roomprice, roomsel, rmax));
  // 1 人部屋:5,000 円、3 人部屋:12,000 円、7 人部屋:20,000 円
  // 動いたら、「13 人部屋 3 万円」
  //「17 人部屋 4 万円」の選択肢を追加して動かしてみなさい。
  ASSERT_EQ(room1(-2, roomprice), 0);
  ASSERT_EQ(room1(-1, roomprice), 0);
  ASSERT_EQ(room1(0, roomprice), 0);
  ASSERT_EQ(room1(1, roomprice), 5000);
  ASSERT_EQ(room1(10, roomprice), 30000);
  ASSERT_EQ(room1(11, roomprice), 30000);
  ASSERT_EQ(room1(12, roomprice), 30000);
  ASSERT_EQ(room1(13, roomprice), 30000);
  ASSERT_EQ(room1(14, roomprice), 35000);
  ASSERT_EQ(room1(15, roomprice), 40000);
  ASSERT_EQ(room1(16, roomprice), 40000);
  ASSERT_EQ(room1(17, roomprice), 40000);
  ASSERT_EQ(room1(18, roomprice), 45000);
  ASSERT_EQ(room1(19, roomprice), 50000);
  ASSERT_EQ(room1(20, roomprice), 50000);
  free(roomprice);
  free(roomsel);
}

// あえて失敗するテストケースも書いておく。
/*TEST_F(fixtureName, sqrt03)
{

}*/
/==============================================================================/
◆課題コード(演習5)
/========================lec012/modules/fp12_05_module.c=======================/

/==============================================================================/
◆テストコード(演習5)
/=======================lec012/test/fp12_05/Makefile===========================/
# Makefile
# all:より下の3行のインデント、
# gtest-gen:より下の1行のインデント
# は半角空白になっていますがタブ1個にしてください
# target.cはCなのでgccで、それ以外はC++なのでg++でビルドします
# gtest_main.ccはGoogleTestが用意してくれているmain関数、
# gtest-all.ccがGoogleTest全部入りファイルです
# -lpthreadをつけることにも注意。
# makeかmake allしたらビルドして実行まで行います。
all:
			gcc -c ../../modules/fp12_05_module.c
			g++ fp12_05_test.cpp googletest-release-1.8.1/googletest/src/gtest_main.cc gtest/gtest-all.cc -I. -lpthread fp12_05_module.o
			./a.out
gtest-gen:
			python googletest-release-1.8.1/googletest/scripts/fuse_gtest_files.py ./
clean:

			rm -f ./a.out
			rm -f ./fp12_05_module.o
/==============================================================================/
/====================lec012/test/fp12_05/fp12_05_target.h======================/
// テスト対象関数のプロトタイプ宣言
#ifndef _TARGET_H_
#define _TARGET_H_

int coin(int i, int *c);
int initialize(int *c, int *csel, int rmax);

#endif /* _TARGET_H_ */
/==============================================================================/
/====================lec012/test/fp12_05/fp12_05_test.cpp======================/
#define RMAX 1000
#define TRUE 1
#define FALSE 0

// テストケース記述ファイル
#include "gtest/gtest.h" // googleTestを使用するおまじないはこれだけでOK
// テスト対象関数を呼び出せるようにするのだが
// extern "C"がないとCと解釈されない、意外とハマりがち。
extern "C" {
  #include "fp12_05_target.h"
}

// fixtureNameはテストケース群をまとめるグループ名と考えればよい、任意の文字列
// それ以外のclass～testing::Testまではおまじないと考える
class fixtureName : public ::testing::Test {
protected:
    // fixtureNameでグループ化されたテストケースはそれぞれのテストケース実行前に
    // この関数を呼ぶ。共通の初期化処理を入れておくとテストコードがすっきりする
    virtual void SetUp(){
    }
    // SetUpと同様にテストケース実行後に呼ばれる関数。共通後始末を記述する。
    virtual void TearDown(){
    }
};

// 成功するテストケース。細かい説明はGoogleTestのマニュアルを見てね。
TEST_F(fixtureName, initialize)
{
  //initialize では先のアルゴリズムによって roomprice を順に初期化しています
  int rmax = 11;
  int *c = (int *)malloc(rmax * sizeof(int));
  int *csel = (int *)malloc(rmax * sizeof(int));
  int *null_num = NULL;
  EXPECT_TRUE(initialize(c, csel, rmax));
  EXPECT_FALSE(initialize(null_num, csel, rmax));
  EXPECT_FALSE(initialize(c, null_num, rmax));
  EXPECT_FALSE(initialize(c, csel, 0));
  free(c);
  free(csel);
}
TEST_F(fixtureName, coin1)
{
  int rmax = 27;
  int *c = (int *)malloc(rmax * sizeof(int));
  int *csel = (int *)malloc(rmax * sizeof(int));
  EXPECT_TRUE(initialize(c, csel, rmax));
  ASSERT_EQ(coin(-2, c), 0);
  ASSERT_EQ(coin(-1, c), 0);
  ASSERT_EQ(coin(0, c), 0);
  ASSERT_EQ(coin(1, c), 1);
  ASSERT_EQ(coin(2, c), 2);
  ASSERT_EQ(coin(3, c), 3);
  ASSERT_EQ(coin(4, c), 4);
  ASSERT_EQ(coin(5, c), 1);
  ASSERT_EQ(coin(6, c), 2);
  ASSERT_EQ(coin(7, c), 3);
  ASSERT_EQ(coin(8, c), 4);
  ASSERT_EQ(coin(9, c), 5);
  ASSERT_EQ(coin(10, c), 1);
  ASSERT_EQ(coin(11, c), 2);
  ASSERT_EQ(coin(12, c), 3);
  ASSERT_EQ(coin(20, c), 2);
  ASSERT_EQ(coin(21, c), 3);
  ASSERT_EQ(coin(24, c), 6);
  ASSERT_EQ(coin(25, c), 1);
  ASSERT_EQ(coin(26, c), 2);
  free(c);
  free(csel);
}

TEST_F(fixtureName, coin2)
{
  int rmax = 21;
  int *c = (int *)malloc(rmax * sizeof(int));
  int *csel = (int *)malloc(rmax * sizeof(int));
  EXPECT_TRUE(initialize(c, csel, rmax));
//  ASSERT_EQ(coin(-2, roomprice), 0);
//  ASSERT_EQ(coin(-1, roomprice), 0);
/*  ASSERT_EQ(coin(0, roomprice), 0);
  ASSERT_EQ(coin(1, roomprice), 1);
  ASSERT_EQ(coin(10, roomprice), 1);
  ASSERT_EQ(coin(11, roomprice), 2);
  ASSERT_EQ(coin(12, roomprice), 3);
  ASSERT_EQ(coin(13, roomprice), 4);
  ASSERT_EQ(coin(14, roomprice), 5);
  ASSERT_EQ(coin(15, roomprice), 2);
  ASSERT_EQ(coin(16, roomprice), 3);
  ASSERT_EQ(coin(17, roomprice), 4);
  ASSERT_EQ(coin(18, roomprice), 5);
  ASSERT_EQ(coin(19, roomprice), 6);
  ASSERT_EQ(coin(20, roomprice), 2);*/
  free(c);
  free(csel);
}

// あえて失敗するテストケースも書いておく。
/*TEST_F(fixtureName, sqrt03)
{

}*/
/==============================================================================/
[考察]
◆実行結果(課題4)
/------------------------------------------------------------------------------/
sheepdog@sheepdog-PC:/mnt/c/Git/fp18/lec012$ ./a.out
input number (0 for end)> 1
room price for 1 => 5000; 1
input number (0 for end)> 2
room price for 2 => 10000; 1 1
input number (0 for end)> 3
room price for 3 => 12000; 3
input number (0 for end)> 4
room price for 4 => 17000; 1 3
input number (0 for end)> 5
room price for 5 => 20000; 7
input number (0 for end)> 6
room price for 6 => 20000; 7
input number (0 for end)> 7
room price for 7 => 20000; 7
input number (0 for end)> 8
room price for 8 => 25000; 1 7
input number (0 for end)> 9
room price for 9 => 30000; 1 1 7
input number (0 for end)> 10
room price for 10 => 30000; 13
input number (0 for end)> 11
room price for 11 => 30000; 13
input number (0 for end)> 12
room price for 12 => 30000; 13
input number (0 for end)> 13
room price for 13 => 30000; 13
input number (0 for end)> 14
room price for 14 => 35000; 1 13
input number (0 for end)> 15
room price for 15 => 40000; 1 1 13
input number (0 for end)>
/------------------------------------------------------------------------------/
◆UT(演習4)
/------------------------------------------------------------------------------/
sheepdog@sheepdog-PC:/mnt/c/Git/fp18/lec012/test/fp12_04$ make
gcc -c ../../modules/fp12_04_module.c
g++ fp12_04_test.cpp googletest-release-1.8.1/googletest/src/gtest_main.cc gtest/gtest-all.cc -I. -lpthread fp12_04_module.o
./a.out
Running main() from googletest-release-1.8.1/googletest/src/gtest_main.cc
[==========] Running 3 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 3 tests from fixtureName
[ RUN      ] fixtureName.initialize
[       OK ] fixtureName.initialize (0 ms)
[ RUN      ] fixtureName.room1
[       OK ] fixtureName.room1 (0 ms)
[ RUN      ] fixtureName.room2
[       OK ] fixtureName.room2 (0 ms)
[----------] 3 tests from fixtureName (3 ms total)

[----------] Global test environment tear-down
[==========] 3 tests from 1 test case ran. (5 ms total)
[  PASSED  ] 3 tests.
/------------------------------------------------------------------------------/
◆UT(演習5)
/------------------------------------------------------------------------------/
sheepdog@sheepdog-PC:/mnt/c/Git/fp18/lec012/test/fp12_05$ make
gcc -c ../../modules/fp12_05_module.c
g++ fp12_05_test.cpp googletest-release-1.8.1/googletest/src/gtest_main.cc gtest/gtest-all.cc -I. -lpthread fp12_05_module.o
./a.out
Running main() from googletest-release-1.8.1/googletest/src/gtest_main.cc
[==========] Running 3 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 3 tests from fixtureName
[ RUN      ] fixtureName.initialize
[       OK ] fixtureName.initialize (0 ms)
[ RUN      ] fixtureName.coin1
[       OK ] fixtureName.coin1 (0 ms)
[ RUN      ] fixtureName.coin2
[       OK ] fixtureName.coin2 (0 ms)
[----------] 3 tests from fixtureName (1 ms total)

[----------] Global test environment tear-down
[==========] 3 tests from 1 test case ran. (2 ms total)
[  PASSED  ] 3 tests.
/------------------------------------------------------------------------------/
設問のケースの様に特に境界値観点で戻り値の妥当性を検証する必要がある場合、
ユニットテストはほぼ必須であることが確認できた。
設問のケースは条件関係も比較的単純であり、
手打ちで実行しながら戻り値確認を実施することも不可能ではないが、
頻繁にリファクタリングを繰り返す様なケースでは寧ろテストコードが資産となる場合も多くUT導入は必須と考える。
演習5は確認観点が多いためUTのみを実施した。

以下を参考にGoogleTestを導入。
https://qiita.com/igayu/items/9ff003309b237e9ae116
http://opencv.jp/googletestdocs/primer.html#primer-assertions

[アンケート]
Q1. C 言語で配列を取り扱えるようになりましたか。
ある程度。
Q2. 動的計画法を理解しましたか。またどのように思いましたか。
ある程度。
Q3. 課題に対する感想と今後の要望をお書きください。
特になし。
